
Programming Language Model
---------------------------

State Assumptions:
  Real-world software contains lots of defects.
  Most if not all defects are diagnosable given the proper information.
  It is possible to define a general framework for describing a
    programming language.
  For any program P there are an infinite number of equivalent programs.
    Of this set, there is a subset of one or more that is shortest.
  Using this framework it would be possible to create models describing
    optimal, correct constructs for programming languages in general,
    and specific languages.

Assert:
  Given such a model M(L) for programming language L and a program P(L)
    it should be possible to detect, diagnose and fix defects.

Let a programming language L be the interface to a virtual machine
for which the following concepts are well-defined:

  scoping
    type(s)
      storage
      values
      functions that modify scoping, types, storage, values and functions(*)

Such that a program P would be a directed graph of function calls

QUESTION: do i want to use "function" here? perhaps a less-loaded term
such as instruction or operation. i think instruction may work better.

Consider integer arithmetic as a simple programming language:

  scoping: (none)
    type: integer
      storage: one single integer
      values: literal integers
      functions: + - * /


Scoping
  
  Let us consider a program P as an undirected graph G(P). G(P) contains
  one node for each distinct component of P.
  
  Let us define an edge e of G(P) as a defined relationship between two
  components of program P.
  
  Let us define the complexity C(P) as the size of the set of edges E(G(P))
  
  Given such a model, LET US DEFINE A SCOPE as a subgraph S within G(P)
  such that the nodes S(n) within it may be addressed as a single unit.
  
  The purpose of scoping is to reduce the complexity C(P) by limiting the
  number of defined interactions between components.
  
  "Controlling complexity is the essence of computer programming."
                                          -- Brian Kernighan
  
  In the absence of scoping any component of a program may interact any
  other part. That is, the size of set E(G(P)) is !C(P)
  
  Let a scoped subgraph S(G(P)) be called a Software Object.
  
  Object
  
    FIXME: Hmmm, definition needs to be recursive. Work on the
      formal definition.
    
    Given Program P be the set of components
      Let Object O be the non-empty subset of {C} that share scope
    
    An object can be defined as a tuple of (Private, Public) members,
    where Private and Public are sets of objects differing in their
    scope.
  
    +- obj ---+
    | private | members inaccessible to other objects
    | public <-> accessible by other objects
    +---------+
    
    In C they are the built-in scalar types, i.e.
    
      void
      char
      int
      long
      float
      double
    
      These software objects constitute a vector of bits of uniform
      scope. If you can read one you can read all, if you can write
      one bit then you can write all.
  
  Scope affects every object. Every object in a program is assigned
  a scope, either implicitly or explicitly. 


Type
  
  <Scope> <Type>
  
  Language must contain one or more well-defined types.
  
  A well-defined type includes definition of storage and
  results of all operations.


Literal or Constant
  
  <Scope> <Type> <Literal>
  
  0. reference known type
  1. compatible type
    if explicit type
      type and literal must be compatible with one another
  2. if implicit type
      must only one and only one possible interpretation of type
  
  the declaration of a constant/literal value constitutes
  a value "source" vs, which is the first item in a chain of
  one or more value states throughout the lifetime of that
  value.

  
Value ::= <Storage> | <Literal Or Constant>
  
  Let Value now refer to any object that yields a value;
  Storage or a Literal or Constant value


Storage

  <Scope> <Type> <Identifier>

  Let Storage S(Scope, Type, Identifier) be an interface
  implementing the following functions

    Value read(Scope, Type)
    ()    write(Scope, Type, Value)
  
  i.e.
    int i;
    const char *s;
    static struct foo Foo;
  
  storage declaration must...
  
    scope
      0. be within a valid scope, given the context
    
    type
      0. reference an existing type
    
    identifier
      0. identifier scope unique
    
    Value read(Scope, Type)

      0. 

Move(Storage dst, Value src)
  
  Overwrite contents of storage dst with value src
  
  dst <- src
  
  0. type compatibility
  1. if src is storage, it must have been previously written to.
  2. dst should not already contain src value
    if it is not possible for dst to contain anything other than
    the value being written to it.
    consider:
    
      a := b
      a := b
    
    note that it is the combination of storage location AND value, not
    just storage that is important. consider:
    
      a := b
      b := a
    
    note that there are many cases where this can happen, such as
      * C's "volatile". 'src' may be memory-mapped i/o or something similar
      * threaded code. research possibilities.
    exceptions
      * debouncing: purpose of copy is to introduce a small delay
        to allow circuit to settle (microcontroller-style)
  3. 
  
  Read(foo)
  
    where foo is src operand in a Move(dst,src) operation
  
  Write(foo)
  
    where foo is dst operand in a Move(dst,src) operation


Function(Storage out, Value in)
  
  out <- f(in)
  
  An abstraction whereby input Value(s) are transformed and
  written to Storage out.
  
  "Statements" and "Procedures" that operate by "side effects"
  are in fact functions that where the input and output implicitly
  include the entire scope in which the function resides.
  
  Consider:
  
  static int i = 1;
  static void incr(void)
  {
    i = i + 1;
    printf("i <- %d\n", i);
  }
  
  all such programs can be re-written as a function in the following
  manner:
  
  static struct translation_unit_scope { FILE *out; int i; } Global = { stdout, 1 };
  static void incr(struct translation_unit_scope *g)
  {
    g->i = g->i + 1;
    fprintf(g->out, "i <- %d\n", g->i);
  }
  
  the point is to illustrate explicitly what happens implicitly in the context
  of a "procedure" -- that 
  
  alternatively, incr() can also be written like so:
  
  static struct translation_unit_scope incr(const struct translation_unit_scope *g)
  {
    struct translation_unit_scope g2 = {
      g->out,
      g->i + 1
    }
    fprintf(g2->out, "i <- %d\n", g2->i);
    return g2;
  }




hmm, let's think about control flow.
how do we move between ...
hmm we haven't really defined an abstraction for dealing with expressions/statements

Branch(Location loc)
  
  
  
  foo: goto foo;  /* C                */
  0xeb 0xfe       /* x86 machine code */
  

Test(Storage dst, Comparison cmp, Value a, Value b)
  FIXME: hmm, is this really fundamental?
  

  
  



Do we want to define functions, in the abstract, mathematical sense?
If I do, I think the whole thing might fall into the lambda calculus area;
which is nice and all, but not where I want to go.



Brainstorm way ahead:
  function must have exactly one entry point
  function must have exactly one exit point


Reference:

   1. http://en.wikipedia.org/wiki/Function_(mathematics)
   2. http://en.wikipedia.org/wiki/Domain_(mathematics)
   3. http://en.wikipedia.org/wiki/Codomain
   4. http://en.wikipedia.org/wiki/Category_theory
   5. http://en.wikipedia.org/wiki/Type_theory
   6. http://en.wikipedia.org/wiki/Programming_language_theory
   7. http://en.wikipedia.org/wiki/Type_system
   8. http://en.wikipedia.org/wiki/Turing_machine
   9. http://en.wikipedia.org/wiki/Graph_theory
  10. http://en.wikipedia.org/wiki/Formal_semantics_of_programming_languages

